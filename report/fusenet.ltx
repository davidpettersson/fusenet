%
% fusenet.ltx
%

\documentclass[11pt,a4paper,titlepage]{article}

\usepackage[swedish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{latexsym}
\usepackage[dvips]{graphicx}
\usepackage{palatino}

\newcommand{\fusenet}{\texttt{\textbf{fusenet}}~}
\newcommand{\class}[1]{\textit{#1}}

\title{\fusenet\\{\Large En lösning på projektuppgiften i kursen C++-programmering}}

\date{\today} % 17 april 2005

\author{ Alexander Felix (someone@someplace) \and Ian Kumlien
  (pomac@vapor.com) \and David Pettersson (david@shebang.nu)}

\begin{document}

\maketitle

\tableofcontents

\section{Introduktion}

\fusenet är en implementation av både klient och server för det
Usenet-liknande protokoll som beskrivs i Per Holms projektbeskrivning
för kursen i C++-programming. 

Implementationen består av en enda exekverbar fil som, beroende på
vilka flaggor som angetts, kan agera såväl server som klient. Klienten
har ett väldigt spartanskt textbaserat användargränssnitt, servern
saknar helt ett interaktivit gränssnitt -- det enda den gör är att
logga vad som pågår till terminalen.

Enligt projektbeskrivningen skulle servern ha två möjliga databaser:
en diskbaserad och vars livslängs sträcker sig över flera körningar
med applikationen, samt en som är minnesbaserad och vars livslängd är
begränsad till den pågående körningen.

\section{Användarhandledning}

Oavsett vilken del av applikationen man vill köra så ska man alltid
exekvera samma binär, dock med olika flaggor. Nedan ges en beskrivning
av hur man kör de olika delfunktionaliteterna. Beskrivningarna
förutsätter att du har byggt applikationen och att du befinner dig i
\verb+build/+-katalogen. 

Du får också en kort syntaxhjälp om du kör applikationen utan några
flaggor.

\subsection{Klient}

För att använda klienten måste du veta vilket datornamn och port som
servern du önskar koppla upp dig mot finns på. När du väl vet detta så
kan du starta klienten på följande sätt:

\begin{verbatim}
  ./fusenet --client DATOR PORT
\end{verbatim}

\noindent där \verb+DATOR+ ersätt med datornamnet på vilken servern
körs, och \verb+PORT+ med portnumret som önskas. Om du inte kör
applikationen som användaren \verb+root+ måste du välja ett portnummer
större än 1024 men mindre än 65536. Giltiga kommandon i klienten får
du om du anger kommandot \verb+h+.

\subsection{Server}

För att använda servern måste du först bestämma dig för vilken
lagringsmetod du önskar, och vilken port du önskar använda. När du väl
veta detta kan du starta servern på följande sätt:

\begin{verbatim}
  ./fusenet --server PORT LAGRING
\end{verbatim}

\noindent där \verb+PORT+ är den port du önskar använda, och
\verb+LAGRING+ antingen är \verb+mem+ för internminnet eller \verb+fs+
för filsystemet. Servern avslutas genom att trycka Ctrl+C.

Om du vill ta bort filsystemsdatabasen så gör du det enklast genom att
ta bort underkatalogen \verb+db/+ som skapats efter körningen med
server och filsystemdatabasen. Ändra dock inget i denna katalog då den
annars kan bli korrupt.

\section{Design}

Applikationens design har försökts hållas så enkel som möjligt. Målet
har varit att det ska vara uppenbart hur applikationen är uppbyggd,
och vad varje klass och fil ansvarar för.

För att förenkla förståelsen så har en stor del av koden dokumenterats
med hjälp av verktyget Doxygen\cite{doxygen}, som närmast kan jämföras
med \verb+javadoc+ för C++.  Detta verktyg framställer klassdiagram i
UML-stil, samt extraherar dokumentationen om klasser och metoder från
källkoden. Denna referensmanual finns tillgänglig på
nätet\cite{refman}.

\subsection{Kommunikation}

För att göra kommunikationen enkel har
\class{Reactor}-mönstret\cite{reactor} som Schmidt tagit fram
använts. Eftersom servern, och i princip klienten, båda är objekt som
är händelsebaserade visade sig detta mönster vara ett bra sätt att
hantera både exekveringsflödet och protokollhanteringen.

\class{Reactor}-mönstret bygger på att man har ett objekt som reagerar
på händelser från ett viss källa, i detta fall nätverket, och som
distribuerar vidare dessa händelser till en eller flera
hanterare. Dessa hanterare behöver inte veta något om den
underliggande transporten, bara de ges möjlighet att kunna skicka
tillbaka data via den. 

I implementationen så är det klassen \class{NetworkReactor} som
handhar distributionen av nätverkshändelsern till instanser av
subklasser till gränssnittsklassen \class{Protocol}. För att göra det
möjligt för protokollen att skicka tillbaka data, har en
gränssnittsklass \class{Transport} används, som har en subklass
\class{SocketTransport} som handhar läsandet och skrivandet till
nätverkskopplingen.

När en ny klient ansluter sig så skapar \class{NetworkReactor} en ny
protokollinstans med hjälp av klassen
\class{ProtocolCreator}. Därefter skapas en instans av
\class{SocketTransport} och protokollinstansen meddelas att en ny
uppkoppling är skapad. När sedan data anländer till denna instans så
ser \class{NetworkReactor} till att rätt instans får data.

Protokollet är implementerat i flera nivåer, där varje nivå
abstraherar kommunikationen. \class{NetworkReactor} är inte medveten
om vilket protokoll det är som används, bara att den har förmågan att
kommunicera via det gränssnittet som presenteras i
\class{Transport}. I implementationen återfinns ett antal olika
protokollnivåer:

\begin{description}

\item[\class{Protocol}] är den grundläggande protokollklassen. Denna
  klass har metoder som låter \class{NetworkReactor} meddela den om
  grundläggande händelser såsom att en uppkoppling har skett eller
  försvunnit, och att data har anlänt. Denna klass innehar också en
  referens till transporten vilket gör det möjligt för den att skicka
  tillbaka data.

\item[\class{MessageProtocol}] abstraherar bort tolkning av de olika
  primitiverna i det givna protokollet. Med hjälp av denna klass kan
  man direkt läsa och skriva parametrar, strängar och kommandon utan
  att behöva bekymra sig om hur de ska skickas över transporten.

\item[\class{ClientProtocol} och \class{ServerProtocol}] är något av
  parhästar när det gäller de övergripande kommandona. Det är i dessa
  två klasser huvudfunktionaliteten när det gäller kommunikationen
  finns.

  I \class{ClientProtocol} finns det en metod \class{listNewsgroups()}
  som skickar iväg kommandon för att lista alla nyhetsgrupper. När
  kommandot anländer på serversidan så anropas
  \class{onListNewsgroups()}, databasen tillfrågas och svaret skickas
  med \class{replyListNewsgroups()}. När svaret anländer hos klient
  anropas denna gång \class{onListNewsgroups()} med en vektor på alla
  nyhetgrupper på servern. På samma sätt fungerar alla andra
  kommandon.

\item[\class{Client} och \class{Server}] är bägge ändpunkter på
  respektive sida. \class{Client} driver interaktionen med användaren
  och skickar iväg frågorna, och \class{Server} delegerar vidare
  frågorna till rätt databastyp. 

\end{description}

Denna design har gjort den enkelt att både implementera och testa att
kommunikationen fungerar felfritt. Det har också lett till mindre kod
och större återanvändning.

\subsection{Lagring}

Lagring av nyhetsgrupper och artiklar sker antingen i internminnet
eller mot disk. Gemensamt för de bägge är att de båda uppfyller
\class{Database}-gränssnittet.

Klassen \class{MemoryDatabase} handhar lagring i internminnet med
hjälp av standardbibliotekets vektorklass. Klassen
\class{FilesystemDatabase} handhar på samma sätt lagringen i
filsystemet. Struktur för artiklar och nyhetsgrupper lagras framgår ur
referensmanualen\cite{refman}.

För att vi skulle få samma beteende togs också särkilda unittester
fram för \class{Database}-gränssnittet. Detta vad ett väldigt bra sätt
att se till så att allting fungerade precis likandant oavsett
databastyp.

\section{Sammanfattning}

Sammanfattningsvis finns inte särskilt mycket att tillägga. Alla krav
har uppfyllts på server och klient har uppfyllts vad vi
vet. Nätverksklasserna kunde som sagt inte återanvändas. De användes
inledningsvis, men via ett adaptionslager.

Det enda som protokollet bör kompletteras med är en statuskod för
eventuella fel som kan uppstå när man listar nyhetersgrupper. Alla
andra kommandon har detta.

\begin{thebibliography}{99}

\bibitem{doxygen}
  Doxygen.\\ \verb+http://www.doxygen.org+

\bibitem{refman}
  Referensmanual.\\ \verb+http://shebang.nu/~david/fusenet/+

\bibitem{reactor} Schmidt, \emph{Reactor -- An Object Behavioral
  Pattern for Event Demultiplexing and Event Handler Dispatching}.\\
  \verb+http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf+

\end{thebibliography}

\end{document}
